#ifndef DITTOFFI_H
#define DITTOFFI_H

/* Store-related forward declarations */
struct Ditto_Expression;
typedef struct Ditto_Expression Ditto_Expression;
struct Ditto_ReadTransaction;
typedef struct Ditto_ReadTransaction Ditto_ReadTransaction;
struct Ditto_WriteTransaction;
typedef struct Ditto_WriteTransaction Ditto_WriteTransaction;
struct Ditto_QueryFilter;
typedef struct Ditto_QueryFilter Ditto_QueryFilter;
struct Ditto_CollectionNames;
typedef struct Ditto_CollectionNames Ditto_CollectionNames;


/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Bit mask. If 1, the write or notify operation accepted this data. If 0, a
 * retry will be required.
 */
#define SEND_RESULT_ACCEPTED 1

/**
 * Bit mask. If 1, wait for ready_to_send event for this remote peer before
 * next send. If 0, more data can be sent immediately.
 */
#define SEND_RESULT_WAIT_FOR_READY 2

/**
 * Describes how an attachment file should be handled by our Rust code.
 *
 * In most cases copying the file will be desirable but with the Android SDK,
 * for example, we sometimes want to create a tempfile from an InputStream
 * associated with the attachment file and then move that tempfile rather than
 * copy it, so as to not make unnecessary copies.
 */
enum AttachmentFileOperation {
  ATTACHMENT_FILE_OPERATION_COPY = 1,
  ATTACHMENT_FILE_OPERATION_MOVE,
};

/**
 * When receiving data from a Bluetooth LE peer, such as a characteristic
 * write, indicates what sort of data it is.
 */
enum BleDataType {
  /**
   * The data _should_ contain the remote peer's announce string.
   * Used during handshake.
   */
  BLE_DATA_TYPE_ANNOUNCE = 0,
  /**
   * Data message
   */
  BLE_DATA_TYPE_MESH_DATA = 1,
  /**
   * Control message
   */
  BLE_DATA_TYPE_CONTROL = 2,
};

enum CLogLevel {
  C_LOG_LEVEL_ERROR = 1,
  C_LOG_LEVEL_WARNING,
  C_LOG_LEVEL_INFO,
  C_LOG_LEVEL_DEBUG,
  C_LOG_LEVEL_VERBOSE,
};

/**
 * User-friendly categories describing where condition events arose
 */
enum ConditionSource {
  CONDITION_SOURCE_BLUETOOTH,
  CONDITION_SOURCE_TCP,
  CONDITION_SOURCE_AWDL,
  CONDITION_SOURCE_MDNS,
};

/**
 * Generic enum used by crate and platforms to indicate a connection status
 */
enum ConnectState {
  CONNECT_STATE_DISCONNECTED,
  CONNECT_STATE_CONNECTED,
  CONNECT_STATE_CONNECTING,
  CONNECT_STATE_DISCONNECTING,
};

/**
 * Generic enum used by crate and platforms to indicate online-ness.
 *
 * In other words, is something active or not? Not everything will use the
 * transitional states.
 */
enum OnlineState {
  ONLINE_STATE_OFFLINE,
  ONLINE_STATE_ONLINE,
  ONLINE_STATE_GOING_ONLINE,
  ONLINE_STATE_GOING_OFFLINE,
};

/**
 * Query compilation result
 */
enum Ditto_QueryCompileResult {
  /**
   * Compilation was successful.
   */
  QUERY_COMPILE_RESULT_QUERY_COMPILE_SUCCESS = 0,
  /**
   * Invalid input. Can be wrong syntax, wrong result type, etc.
   */
  QUERY_COMPILE_RESULT_QUERY_COMPILE_INVALID_INPUT = 1,
  /**
   * Failure during compilation or transpilation.
   */
  QUERY_COMPILE_RESULT_QUERY_COMPILE_COMPILE_FAILED = 2,
};

enum QuerySortDirection {
  QUERY_SORT_DIRECTION_ASCENDING = 1,
  QUERY_SORT_DIRECTION_DESCENDING,
};

/**
 * A code reported by platforms/transports to indicate specific health
 * conditions
 */
enum TransportCondition {
  /**
   * A default state. Only use this for transient conditions, e.g., we are
   * waiting for a platform to finish starting up. If everything is just
   * quiet, use `Ok`.
   */
  TRANSPORT_CONDITION_UNKNOWN,
  /**
   * No known problems.
   */
  TRANSPORT_CONDITION_OK,
  /**
   * Catch-all failure, particularly for unexpected/internal faults. If
   * possible, add a new case that the customer will be able to
   * interpret.
   */
  TRANSPORT_CONDITION_GENERIC_FAILURE,
  /**
   * App is in background.
   */
  TRANSPORT_CONDITION_APP_IN_BACKGROUND,
  /**
   * We are not able to publish or discover with the mDNS daemon.
   */
  TRANSPORT_CONDITION_MDNS_FAILURE,
  /**
   * We cannot bind to a port.
   */
  TRANSPORT_CONDITION_TCP_LISTEN_FAILURE,
  /**
   * No app permission to act as a BLE Central.
   */
  TRANSPORT_CONDITION_NO_BLE_CENTRAL_PERMISSION,
  /**
   * No app permission to act as a BLE Peripheral.
   */
  TRANSPORT_CONDITION_NO_BLE_PERIPHERAL_PERMISSION,
  /**
   * This Transport targets a particular peer and we can't reach them right
   * now.
   */
  TRANSPORT_CONDITION_CANNOT_ESTABLISH_CONNECTION,
  /**
   * The device has Bluetooth disabled at the OS level.
   */
  TRANSPORT_CONDITION_BLE_DISABLED,
  /**
   * The device has no Bluetooth hardware.
   */
  TRANSPORT_CONDITION_NO_BLE_HARDWARE,
  /**
   * The device has Wifi disabled at the OS level.
   */
  TRANSPORT_CONDITION_WIFI_DISABLED,
  /**
   * The platform has suspended briefly for internal reasons. Peers are
   * reset.
   */
  TRANSPORT_CONDITION_TEMPORARILY_UNAVAILABLE,
};

/**
 * A shared read-only reference to an existing Attachment.
 */
struct AttachmentHandle;

/**
 * Read transaction synchronous API.
 */
struct Ditto_ReadTransaction;

/**
 * Write transaction synchronous API.
 */
struct Ditto_WriteTransaction;

struct Ditto;

/**
 * Database document
 */
struct Ditto_Document;

/**
 * An opaque handle for each installed transport, heap-allocated and owned by the SDK.
 *
 * A pointer to this handle is used to send platform events over FFI. In the future this
 * handle will be the SDK's only point of control over the transport once created. In
 * particular, a transport will be removed by freeing the handle. The concept of online
 * and offline will be eliminated. (i.e., if you don't want a transport, remove it.)
 *
 * For now, the `Peer` object holds the transports and provides an API based on a
 * numeric id assigned to each transport instance. Until that is removed, the id still
 * exists and the SDK can request it from the opaque handle over FFI.
 *
 * For each transport type, define an `extern "C"` function to free that specific
 * monomorphisation of the `TransportHandle` using `Box::from_raw`, plus a function to
 * retrieve the transport id, which will be removed later.
 *
 * Safety: The SDK owns the `TransportHandle`. It is responsible for ensuring that it does
 * not use the pointer to the `TransportHandle` after freeing it with its respective
 * function. In Rust we will assume it is okay to unsafely dereference a handle.
 *
 * The C interface of `TransportHandle` is thread-safe (`Send + Sync`).
 */
struct TransportHandle_AwdlClientPlatformEvent;

/**
 * An opaque handle for each installed transport, heap-allocated and owned by the SDK.
 *
 * A pointer to this handle is used to send platform events over FFI. In the future this
 * handle will be the SDK's only point of control over the transport once created. In
 * particular, a transport will be removed by freeing the handle. The concept of online
 * and offline will be eliminated. (i.e., if you don't want a transport, remove it.)
 *
 * For now, the `Peer` object holds the transports and provides an API based on a
 * numeric id assigned to each transport instance. Until that is removed, the id still
 * exists and the SDK can request it from the opaque handle over FFI.
 *
 * For each transport type, define an `extern "C"` function to free that specific
 * monomorphisation of the `TransportHandle` using `Box::from_raw`, plus a function to
 * retrieve the transport id, which will be removed later.
 *
 * Safety: The SDK owns the `TransportHandle`. It is responsible for ensuring that it does
 * not use the pointer to the `TransportHandle` after freeing it with its respective
 * function. In Rust we will assume it is okay to unsafely dereference a handle.
 *
 * The C interface of `TransportHandle` is thread-safe (`Send + Sync`).
 */
struct TransportHandle_AwdlServerPlatformEvent;

/**
 * An opaque handle for each installed transport, heap-allocated and owned by the SDK.
 *
 * A pointer to this handle is used to send platform events over FFI. In the future this
 * handle will be the SDK's only point of control over the transport once created. In
 * particular, a transport will be removed by freeing the handle. The concept of online
 * and offline will be eliminated. (i.e., if you don't want a transport, remove it.)
 *
 * For now, the `Peer` object holds the transports and provides an API based on a
 * numeric id assigned to each transport instance. Until that is removed, the id still
 * exists and the SDK can request it from the opaque handle over FFI.
 *
 * For each transport type, define an `extern "C"` function to free that specific
 * monomorphisation of the `TransportHandle` using `Box::from_raw`, plus a function to
 * retrieve the transport id, which will be removed later.
 *
 * Safety: The SDK owns the `TransportHandle`. It is responsible for ensuring that it does
 * not use the pointer to the `TransportHandle` after freeing it with its respective
 * function. In Rust we will assume it is okay to unsafely dereference a handle.
 *
 * The C interface of `TransportHandle` is thread-safe (`Send + Sync`).
 */
struct TransportHandle_BleClientPlatformEvent;

/**
 * An opaque handle for each installed transport, heap-allocated and owned by the SDK.
 *
 * A pointer to this handle is used to send platform events over FFI. In the future this
 * handle will be the SDK's only point of control over the transport once created. In
 * particular, a transport will be removed by freeing the handle. The concept of online
 * and offline will be eliminated. (i.e., if you don't want a transport, remove it.)
 *
 * For now, the `Peer` object holds the transports and provides an API based on a
 * numeric id assigned to each transport instance. Until that is removed, the id still
 * exists and the SDK can request it from the opaque handle over FFI.
 *
 * For each transport type, define an `extern "C"` function to free that specific
 * monomorphisation of the `TransportHandle` using `Box::from_raw`, plus a function to
 * retrieve the transport id, which will be removed later.
 *
 * Safety: The SDK owns the `TransportHandle`. It is responsible for ensuring that it does
 * not use the pointer to the `TransportHandle` after freeing it with its respective
 * function. In Rust we will assume it is okay to unsafely dereference a handle.
 *
 * The C interface of `TransportHandle` is thread-safe (`Send + Sync`).
 */
struct TransportHandle_BleServerPlatformEvent;

/**
 * An opaque handle for each installed transport, heap-allocated and owned by the SDK.
 *
 * A pointer to this handle is used to send platform events over FFI. In the future this
 * handle will be the SDK's only point of control over the transport once created. In
 * particular, a transport will be removed by freeing the handle. The concept of online
 * and offline will be eliminated. (i.e., if you don't want a transport, remove it.)
 *
 * For now, the `Peer` object holds the transports and provides an API based on a
 * numeric id assigned to each transport instance. Until that is removed, the id still
 * exists and the SDK can request it from the opaque handle over FFI.
 *
 * For each transport type, define an `extern "C"` function to free that specific
 * monomorphisation of the `TransportHandle` using `Box::from_raw`, plus a function to
 * retrieve the transport id, which will be removed later.
 *
 * Safety: The SDK owns the `TransportHandle`. It is responsible for ensuring that it does
 * not use the pointer to the `TransportHandle` after freeing it with its respective
 * function. In Rust we will assume it is okay to unsafely dereference a handle.
 *
 * The C interface of `TransportHandle` is thread-safe (`Send + Sync`).
 */
struct TransportHandle_MdnsClientPlatformEvent;

/**
 * An opaque handle for each installed transport, heap-allocated and owned by the SDK.
 *
 * A pointer to this handle is used to send platform events over FFI. In the future this
 * handle will be the SDK's only point of control over the transport once created. In
 * particular, a transport will be removed by freeing the handle. The concept of online
 * and offline will be eliminated. (i.e., if you don't want a transport, remove it.)
 *
 * For now, the `Peer` object holds the transports and provides an API based on a
 * numeric id assigned to each transport instance. Until that is removed, the id still
 * exists and the SDK can request it from the opaque handle over FFI.
 *
 * For each transport type, define an `extern "C"` function to free that specific
 * monomorphisation of the `TransportHandle` using `Box::from_raw`, plus a function to
 * retrieve the transport id, which will be removed later.
 *
 * Safety: The SDK owns the `TransportHandle`. It is responsible for ensuring that it does
 * not use the pointer to the `TransportHandle` after freeing it with its respective
 * function. In Rust we will assume it is okay to unsafely dereference a handle.
 *
 * The C interface of `TransportHandle` is thread-safe (`Send + Sync`).
 */
struct TransportHandle_MdnsServerPlatformEvent;

/**
 * An opaque handle for each installed transport, heap-allocated and owned by the SDK.
 *
 * A pointer to this handle is used to send platform events over FFI. In the future this
 * handle will be the SDK's only point of control over the transport once created. In
 * particular, a transport will be removed by freeing the handle. The concept of online
 * and offline will be eliminated. (i.e., if you don't want a transport, remove it.)
 *
 * For now, the `Peer` object holds the transports and provides an API based on a
 * numeric id assigned to each transport instance. Until that is removed, the id still
 * exists and the SDK can request it from the opaque handle over FFI.
 *
 * For each transport type, define an `extern "C"` function to free that specific
 * monomorphisation of the `TransportHandle` using `Box::from_raw`, plus a function to
 * retrieve the transport id, which will be removed later.
 *
 * Safety: The SDK owns the `TransportHandle`. It is responsible for ensuring that it does
 * not use the pointer to the `TransportHandle` after freeing it with its respective
 * function. In Rust we will assume it is okay to unsafely dereference a handle.
 *
 * The C interface of `TransportHandle` is thread-safe (`Send + Sync`).
 */
struct TransportHandle_StaticTcpClientPlatformEvent;

struct UninitializedDitto;

typedef struct TransportHandle_AwdlClientPlatformEvent AwdlClientPlatformHandle;

typedef struct TransportHandle_AwdlServerPlatformEvent AwdlServerPlatformHandle;

typedef struct TransportHandle_BleClientPlatformEvent BleClientPlatformHandle;

typedef struct TransportHandle_BleServerPlatformEvent BleServerPlatformHandle;

struct AwdlClientCallbacks {
  void (*start_searching)(void *ctx, const char *announce, const char *app_name);
  void (*stop_searching)(void *ctx);
  void (*request_connect)(void *ctx, const char *announce);
  void (*request_disconnect)(void *ctx, const char *announce);
  int (*send_data)(void *ctx, const char*, const unsigned char*, unsigned int);
  int (*read_data)(void *ctx, const char *announce, unsigned char *buf, unsigned int buf_len);
};

struct AwdlServerCallbacks {
  void (*start_advertising)(void *ctx, const char *announce, const char *app_name);
  void (*stop_advertising)(void *ctx);
  void (*request_disconnect)(void *ctx, long long platform_id);
  int (*send_data)(void *ctx, long long platform_id, const unsigned char *data, unsigned int data_len);
  int (*read_data)(void *ctx, long long platform_id, unsigned char *buf, unsigned int buf_len);
};

struct BleClientCallbacks {
  void (*start_scanning)(void *ctx, const unsigned char *service_uuid, const unsigned char *announce, int announce_len);
  void (*stop_scanning)(void *ctx);
  enum OnlineState (*scanning_state)(void *ctx);
  void (*connect_peripheral)(void *ctx, const unsigned char *peripheral_uuid);
  void (*disconnect_peripheral)(void *ctx, const unsigned char *peripheral_uuid);
  unsigned int (*write_to_peripheral)(void *ctx, enum BleDataType send_type, const unsigned char *peripheral_uuid, const unsigned char *data, int data_len);
  bool (*app_is_in_foreground)(void *ctx);
};

struct BleServerCallbacks {
  void (*start_advertising)(void *ctx, const unsigned char *service_uuid, const unsigned char *local_name, int local_name_len);
  void (*stop_advertising)(void *ctx);
  enum OnlineState (*advertising_state)(void *ctx);
  unsigned int (*notify_to_central)(void *ctx, enum BleDataType send_type, const unsigned char *central_uuid, const unsigned char *data, int data_len);
  bool (*app_is_in_foreground)(void *ctx);
};

struct MdnsServerCallbacks {
  void (*start_advertising)(void *ctx, const char *announce, const char *app_name, int service_port);
  void (*stop_advertising)(void *ctx);
};

struct MdnsClientCallbacks {
  void (*start_searching)(void *ctx);
  void (*stop_searching)(void *ctx);
  void (*resolve_service)(void *ctx, const unsigned char *announce, unsigned int announce_len);
};

/**
 * Represents an iterator over collection names
 *
 * When created by `collections` function, the first value of `name`
 * must be set to `NULL` and the `next` function must be used to iterate
 * over it. Once `next` returns 0, the iterator is complete and the
 * instance of this structure is deallocated.
 */
struct Ditto_CollectionNames {
  /**
   * \private
   */
  const void *iterator;
  /**
   * collection name
   */
  char *name;
};

/**
 * Compiled query expression
 */
typedef Ditto_Expression Ditto_CompiledQuery;

/**
 * Order Definition.
 */
struct Ditto_OrderDefinition {
  Ditto_CompiledQuery *projection;
  enum QuerySortDirection direction;
};

/**
 * Query Filter synchronous API.
 */
struct Ditto_QueryFilter {
  /**
   * \private
   */
  const void *query_iter;
};

typedef struct TransportHandle_MdnsServerPlatformEvent MdnsServerPlatformHandle;

typedef struct TransportHandle_MdnsClientPlatformEvent MdnsClientPlatformHandle;

typedef struct TransportHandle_StaticTcpClientPlatformEvent StaticTcpClientPlatformHandle;

/**
 * The platform advises Rust that a peer has changed its current connection
 * status
 */
void awdl_client_connect_state_changed(const AwdlClientPlatformHandle *handle,
                                       const char *announce,
                                       enum ConnectState state);

/**
 * The platform advises Rust that a complete message has been received from a
 * remote peer
 */
void awdl_client_data_available(const AwdlClientPlatformHandle *handle, const char *announce);

/**
 * The SDK requests to drop its handle to the AWDL Client Transport
 *
 * At some point dropping this events channel will effectively shut down and remove the Transport.
 * At time of writing, the Transport is still owned within Peer.
 */
void awdl_client_free_handle(AwdlClientPlatformHandle *handle);

/**
 * The platform advises Rust that a peer has been identified. We know only its
 * announce string.
 */
void awdl_client_platform_peer_appeared(const AwdlClientPlatformHandle *handle,
                                        const char *announce);

/**
 * The platform advises Rust that a peer has disappeared.
 */
void awdl_client_platform_peer_disappeared(const AwdlClientPlatformHandle *handle,
                                           const char *announce);

/**
 * The platform advises Rust that a given peer is now clear to queue up a new
 * message whenever one is ready to go
 */
void awdl_client_ready_to_send(const AwdlClientPlatformHandle *handle, const char *announce);

/**
 * The platform advises Rust that searching status changed
 */
void awdl_client_scanning_state_changed(const AwdlClientPlatformHandle *handle,
                                        enum OnlineState state,
                                        enum TransportCondition condition);

/**
 * Request the id of this transport
 *
 * This is a temporary accessor until the Peer transports interface is removed.
 */
long long awdl_client_transport_id(const AwdlClientPlatformHandle *handle);

/**
 * The platform advises Rust that advertising status changed
 */
void awdl_server_advertising_state_changed(const AwdlServerPlatformHandle *handle,
                                           enum OnlineState state,
                                           enum TransportCondition condition);

/**
 * The platform advises Rust that a peer has changed its current connection
 * status
 */
void awdl_server_connect_state_changed(const AwdlServerPlatformHandle *handle,
                                       int64_t platform_id,
                                       enum ConnectState state);

/**
 * The platform advises Rust that a complete message has been received from a
 * remote peer
 */
void awdl_server_data_available(const AwdlServerPlatformHandle *handle, int64_t platform_id);

/**
 * The SDK requests to drop its handle to the AWDL Server Transport
 *
 * At some point dropping this events channel will effectively shut down and remove the Transport.
 * At time of writing, the Transport is still owned within Peer.
 */
void awdl_server_free_handle(AwdlServerPlatformHandle *handle);

/**
 * The platform advises Rust that a peer has been identified. We know only its
 * announce string.
 */
void awdl_server_platform_peer_appeared(const AwdlServerPlatformHandle *handle,
                                        int64_t platform_id);

/**
 * The platform advises Rust that a peer has disappeared.
 */
void awdl_server_platform_peer_disappeared(const AwdlServerPlatformHandle *handle,
                                           int64_t platform_id);

/**
 * The platform advises Rust that a given peer is now clear to queue up a new
 * message whenever one is ready to go
 */
void awdl_server_ready_to_send(const AwdlServerPlatformHandle *handle, int64_t platform_id);

/**
 * Request the id of this transport
 *
 * This is a temporary accessor until the Peer transports interface is removed.
 */
long long awdl_server_transport_id(const AwdlServerPlatformHandle *handle);

void ble_advertisement_heard(const BleClientPlatformHandle *handle,
                             const unsigned char *peripheral_uuid,
                             const unsigned char *local_name,
                             int local_name_len);

void ble_advertising_state_changed(const BleServerPlatformHandle *handle,
                                   enum OnlineState state,
                                   enum TransportCondition result);

void ble_central_mtu_updated(const BleServerPlatformHandle *handle,
                             const unsigned char *uuid,
                             unsigned int mtu);

void ble_central_ready_to_send(const BleServerPlatformHandle *handle, const unsigned char *uuid);

void ble_central_unsubscribed(const BleServerPlatformHandle *handle,
                              const unsigned char *central_uuid);

/**
 * The SDK requests to drop its handle to the BLE Client Transport
 *
 * At some point dropping this events channel will effectively shut down and remove the Transport.
 * At time of writing, the Transport is still owned within Peer.
 */
void ble_client_free_handle(BleClientPlatformHandle *handle);

/**
 * Request the id of this transport
 *
 * This is a temporary accessor until the Peer transports interface is removed.
 */
long long ble_client_transport_id(const BleClientPlatformHandle *handle);

void ble_connection_state_changed(const BleClientPlatformHandle *handle,
                                  const unsigned char *peripheral_uuid,
                                  enum ConnectState state);

void ble_peripheral_mtu_updated(const BleClientPlatformHandle *handle,
                                const unsigned char *uuid,
                                unsigned int mtu);

void ble_peripheral_ready_to_send(const BleClientPlatformHandle *handle, const unsigned char *uuid);

void ble_received_from_central(const BleServerPlatformHandle *handle,
                               const unsigned char *central_uuid,
                               enum BleDataType data_type,
                               const unsigned char *data,
                               int data_len);

void ble_received_from_peripheral(const BleClientPlatformHandle *handle,
                                  const unsigned char *peripheral_uuid,
                                  enum BleDataType data_type,
                                  const unsigned char *data,
                                  int data_len);

void ble_scanning_state_changed(const BleClientPlatformHandle *handle,
                                enum OnlineState state,
                                enum TransportCondition result);

/**
 * The SDK requests to drop its handle to the BLE Server Transport
 *
 * At some point dropping this events channel will effectively shut down and remove the Transport.
 * At time of writing, the Transport is still owned within Peer.
 */
void ble_server_free_handle(BleServerPlatformHandle *handle);

/**
 * Request the id of this transport
 *
 * This is a temporary accessor until the Peer transports interface is removed.
 */
long long ble_server_transport_id(const BleServerPlatformHandle *handle);

struct TransportHandle_AwdlClientPlatformEvent *ditto_add_awdl_client_transport(struct Ditto *ditto_raw,
                                                                                struct AwdlClientCallbacks callbacks,
                                                                                void *ctx,
                                                                                void (*retain)(void*),
                                                                                void (*release)(void*));

struct TransportHandle_AwdlServerPlatformEvent *ditto_add_awdl_server_transport(struct Ditto *ditto_raw,
                                                                                struct AwdlServerCallbacks callbacks,
                                                                                void *ctx,
                                                                                void (*retain)(void*),
                                                                                void (*release)(void*));

struct TransportHandle_BleClientPlatformEvent *ditto_add_ble_client_transport(struct Ditto *ditto_raw,
                                                                              struct BleClientCallbacks callbacks,
                                                                              void *ctx,
                                                                              void (*retain)(void*),
                                                                              void (*release)(void*));

struct TransportHandle_BleServerPlatformEvent *ditto_add_ble_server_transport(struct Ditto *ditto_raw,
                                                                              struct BleServerCallbacks callbacks,
                                                                              void *ctx,
                                                                              void (*retain)(void*),
                                                                              void (*release)(void*));

struct TransportHandle_MdnsServerPlatformEvent *ditto_add_mdns_advertiser(struct Ditto *ditto_raw,
                                                                          struct MdnsServerCallbacks callbacks,
                                                                          void *ctx,
                                                                          void (*retain)(void*),
                                                                          void (*release)(void*));

struct TransportHandle_MdnsClientPlatformEvent *ditto_add_mdns_transport(struct Ditto *ditto_raw,
                                                                         struct MdnsClientCallbacks callbacks,
                                                                         void *ctx,
                                                                         void (*retain)(void*),
                                                                         void (*release)(void*));

struct TransportHandle_StaticTcpClientPlatformEvent *ditto_add_static_tcp_client(struct Ditto *ditto_raw,
                                                                                 const char *address);

/**
 * Add a subscription
 */
void ditto_add_subscription(struct Ditto *ditto_raw, const char *collection, const char *query);

/**
 * Releases a byte array value returned by DittoStore.
 *
 * DittoStore manages its own memory allocations and it is not safe to release such values with
 * C's `free()`. That's why the structures it returns provide their own associated `free`
 * function.
 *
 * It should be used for values returned by functions like `ditto_document_cbor`.
 */
void ditto_c_bytes_free(const unsigned char *bytes_ptr, uintptr_t len);

/**
 * Releases `char *` value returned by DittoStore.
 *
 * DittoStore manages its own memory allocations and it is not safe to release
 * such values with C's `free()`. That's why the structures it returns provide
 * their own associated `free` function and this is one we need this function
 * for `char *`.
 *
 * It should be used for values returned by functions like
 * Ditto_QueryFilter::next.
 */
void ditto_c_string_free(char *string);

/**
 * Empty error callback
 * (useful for passing to `err_cb` functions to ignore errors; use with
 * caution)
 */
void ditto_callback_err_nop(int _code, const char *_err, void *_data);

/**
 * Empty callback (useful for passing to `free` functions)
 */
void ditto_callback_nop(const void *_data);

/**
 * Cancels a resolve callback registered by ditto_resolve_attachment.
 *
 * Returns following error codes:
 *
 * * `0` -- no error
 * * `1` -- an error
 * * `2` -- invalid id
 * * `3` -- token not found
 *
 * In case of a non-zero return value, error message can be retrieved using
 * `::ditto_error_message` function.
 */
unsigned int ditto_cancel_resolve_attachment(struct Ditto *ditto_raw,
                                             const unsigned char *id_ptr,
                                             uintptr_t id_len,
                                             int64_t cancel_token);

/**
 * Clear the store of an existing cached site ID, if one exists.
 */
int ditto_clear_site_id(struct Ditto *ditto_raw);

/**
 * Clear the callbacks used for diagnostics.
 */
void ditto_clear_status_callbacks(struct Ditto *ditto_raw);

int ditto_collection(struct Ditto *ditto_raw, const char *name);

int ditto_collection_evict(struct Ditto *ditto_raw,
                           const char *coll_name,
                           const struct Ditto_WriteTransaction *transaction,
                           const char *id,
                           bool *was_evicted);

int ditto_collection_get(struct Ditto *ditto_raw,
                         const char *coll_name,
                         const char *id,
                         const struct Ditto_ReadTransaction *transaction,
                         const struct Ditto_Document **document);

int ditto_collection_insert(struct Ditto *ditto_raw,
                            const char *coll_name,
                            const struct Ditto_WriteTransaction *transaction,
                            struct Ditto_Document *document,
                            char **id);

int ditto_collection_remove(struct Ditto *ditto_raw,
                            const char *coll_name,
                            const struct Ditto_WriteTransaction *transaction,
                            const char *id,
                            bool *was_removed);

int ditto_collection_update(struct Ditto *ditto_raw,
                            const char *coll_name,
                            const struct Ditto_WriteTransaction *transaction,
                            struct Ditto_Document *document);

int ditto_collections(struct Ditto *ditto_raw, struct Ditto_CollectionNames **collections);

void ditto_collections_free(struct Ditto_CollectionNames *collections);

int ditto_collections_next(struct Ditto_CollectionNames *collections);

/**
 * Document's CBOR
 */
const unsigned char *ditto_document_cbor(const struct Ditto_Document *document,
                                         uintptr_t *out_cbor_len);

/**
 * Releases the document
 */
void ditto_document_free(struct Ditto_Document *document);

/**
 * Gets the CBOR value at the pointer
 *
 * Returns NULL if none found
 *
 * The resulting bytes have to be released with `::ditto_c_bytes_free`
 */
const unsigned char *ditto_document_get_cbor(const struct Ditto_Document *document,
                                             const char *pointer,
                                             uintptr_t *out_cbor_len);

/**
 * Document's rendered ID
 *
 * If there's no ID, a NULL will be returned.
 *
 * The resulting string has to be released with `::ditto_c_string_free`
 */
char *ditto_document_id(const struct Ditto_Document *document);

int ditto_document_increment_counter(struct Ditto_Document *document,
                                     const char *pointer,
                                     double amount);

/**
 * Inserts a value into a document. The behavior depends on the `Repr` of the
 * element at the JMESPath path pointed to by `pointer`.
 *
 * ```ignore
 * // ________________________________________________________________________________________
 * // |`pointer`   | Foo `Repr` | Action                                                     |
 * // |------------|------------|------------------------------------------------------------|
 * // | "foo.bar"  | Object     | Sets the bar property to the supplied CBOR item            |
 * // | "foo[1]"   | Array      | Inserts the supplied CBOR item at the index specified      |
 * // ----------------------------------------------------------------------------------------
 * ```
 *
 * # Arguments
 *
 * * `document` - A pointer to the document which was previously passed across the FFI
 *    layer by `ditto_document_new_*` or returned from a query.
 * * `pointer` - A JMESPath _pointer_ to a `Repr` within `document` which is to be removed.
 *
 * # Returns
 *
 * `0` if the remove was successful or non-zero to indicate failure. To retrieve an error
 * message in the case of failure, call `ditto_error_message()`.
 */
int ditto_document_insert_cbor(struct Ditto_Document *document,
                               const char *pointer,
                               const unsigned char *cbor_ptr,
                               uintptr_t cbor_len);

/**
 * Document's rendered JSON
 *
 * The resulting string has to be released with `::ditto_c_string_free`
 */
char *ditto_document_json(const struct Ditto_Document *document);

/**
 * Creates a new document from CBOR
 *
 * It will allocate a new document and set `document` pointer to it. It will
 * later need to be released with `::ditto_document_free`.
 *
 * The input `cbor` must be a valid CBOR.
 *
 * Return codes:
 *
 * * `0` -- success
 * * `1` -- invalid CBOR
 * * `2` -- cbor is not an object
 * * `3` -- ID string is empty
 */
int ditto_document_new_cbor(const unsigned char *cbor_ptr,
                            uintptr_t cbor_len,
                            const char *id,
                            unsigned int site_id,
                            struct Ditto_Document **document);

/**
 * Creates a new document from CBOR and a provided timestamp
 *
 * It will allocate a new document and set `document` pointer to it. It will
 * later need to be released with `::ditto_document_free`.
 *
 * The input `cbor` must be a valid CBOR.
 *
 * Return codes:
 *
 * * `0` -- success
 * * `1` -- invalid CBOR
 * * `2` -- cbor is not an object
 * * `3` -- ID string is empty
 */
int ditto_document_new_cbor_with_timestamp(const unsigned char *cbor_ptr,
                                           uintptr_t cbor_len,
                                           const char *id,
                                           unsigned int site_id,
                                           unsigned int timestamp,
                                           struct Ditto_Document **document);

int ditto_document_pop_cbor(struct Ditto_Document *document,
                            const char *pointer,
                            const unsigned char **cbor_ptr,
                            uintptr_t *out_cbor_len);

int ditto_document_push_cbor(struct Ditto_Document *document,
                             const char *pointer,
                             const unsigned char *cbor_ptr,
                             uintptr_t cbor_len);

/**
 * Removes a value from a document. The behavior depends on the `Repr` of the
 * element at the JMESPath path pointed to by `pointer`.
 *
 * ```ignore
 * // ________________________________________________________________________________________
 * // |`pointer`   | Foo `Repr` | Action                                                     |
 * // |------------|------------|------------------------------------------------------------|
 * // | "foo.bar"  | Object     | Deletes bar property                                       |
 * // | "foo[1]"   | Array      | Removes at index and shifts all subsequent indexes right   |
 * // ----------------------------------------------------------------------------------------
 * ```
 *
 * # Arguments
 *
 * * `document` - A pointer to the document which was previously passed across the FFI
 *    layer by `ditto_document_new_*` or returned from a query.
 * * `pointer` - A JMESPath _pointer_ to a `Repr` within `document` which is to be removed.
 *
 * # Returns
 *
 * `0` if the remove was successful or non-zero to indicate failure. To retrieve an error
 * message in the case of failure, call `ditto_error_message()`.
 */
int ditto_document_remove(struct Ditto_Document *document, const char *pointer);

int ditto_document_replace_with_counter(struct Ditto_Document *document, const char *pointer);

int ditto_document_replace_with_counter_with_timestamp(struct Ditto_Document *document,
                                                       const char *pointer,
                                                       unsigned int timestamp);

int ditto_document_set_cbor(struct Ditto_Document *document,
                            const char *pointer,
                            const unsigned char *cbor_ptr,
                            uintptr_t cbor_len,
                            bool create_path);

int ditto_document_set_cbor_with_timestamp(struct Ditto_Document *document,
                                           const char *pointer,
                                           const unsigned char *cbor_ptr,
                                           uintptr_t cbor_len,
                                           bool create_path,
                                           unsigned int timestamp);

/**
 * Updates the document with values taken from provided CBOR data.
 *
 * Returns following error codes:
 *
 * * `0` -- no error
 * * `1` -- invalid CBOR data
 * * `2` -- CBOR data was not a map
 * * `3` -- update error
 *
 * In case of a non-zero return value, error message can be retrieved using
 * `::ditto_error_message` function.
 */
int ditto_document_update(struct Ditto_Document *document,
                          const unsigned char *cbor_ptr,
                          uintptr_t cbor_len,
                          bool create_path);

/**
 * Retrieves last thread-local error message (used by some synchronous APIs)
 * and removes it. Subsequent call to this function (if nothing else has
 * happened) will always return `NULL`.
 *
 * Returns `NULL` if there was no error. A non-null result MUST be freed using
 * `ditto_c_string_free`.
 */
char *ditto_error_message(void);

/**
 * Retrieves last thread-local error message (used by some synchronous APIs)
 * and retains ownership of it.
 *
 * Returns `NULL` if there was no error. A non-null result MUST NOT be freed
 * using `ditto_c_string_free`.
 */
const char *ditto_error_message_peek(void);

/**
 * Stop replication and all internal threads in the Ditto object.
 * The ditto object is freed by this function and must not be used again.
 */
void ditto_free(struct Ditto *ditto_raw);

void ditto_free_attachment_handle(struct AttachmentHandle *handle_raw);

int ditto_get_attachment_status(struct Ditto *ditto_raw,
                                const unsigned char *id_ptr,
                                uintptr_t id_len,
                                const struct AttachmentHandle **out_handle);

char *ditto_get_complete_attachment_path(struct Ditto *ditto_raw,
                                         const struct AttachmentHandle *handle_raw);

unsigned int ditto_get_site_id(struct Ditto *ditto_raw);

int ditto_live_query(struct Ditto *ditto_raw,
                     const char *coll_name,
                     const Ditto_CompiledQuery *query,
                     const struct Ditto_OrderDefinition *order_by,
                     unsigned int order_by_len,
                     int limit,
                     unsigned int offset,
                     long long *id,
                     void *ctx,
                     void (*retain)(void*),
                     void (*release)(void*),
                     void (*c_cb)(void *ctx, const struct Ditto_Document **documents, uintptr_t document_count, bool is_initial, const struct Ditto_Document **old_documents, uintptr_t old_document_count, uintptr_t *insertions, uintptr_t insertion_count, uintptr_t *deletions, uintptr_t deletion_count, uintptr_t *updates, uintptr_t update_count, uintptr_t *moves, uintptr_t move_count));

void ditto_live_query_stop(struct Ditto *ditto_raw, long long id);

/**
 * Log function called over FFI such that logging can be grouped into a single
 * logging mechanism.
 */
void ditto_log(enum CLogLevel level, const char *msg);

void ditto_logger_emoji_headings_enabled(bool enabled);

void ditto_logger_enabled(bool enabled);

void ditto_logger_init(void);

void ditto_logger_minimum_log_level(enum CLogLevel log_level);

/**
 * Make a Ditto object as an opaque pointer. The Ditto object creates the Tokio
 * runtime and starts internal threads. The return value is a raw pointer whose
 * only use is to supply as an argument to other ditto_* functions. The Ditto
 * object must be stopped and freed with ditto_free().
 */
struct Ditto *ditto_make_development(struct UninitializedDitto *uninit_ditto_raw,
                                     unsigned int site_id,
                                     const char *app_name);

/**
 * Make a Ditto object as an opaque pointer. The Ditto object creates the Tokio
 * runtime and starts internal threads. The return value is a raw pointer whose
 * only use is to supply as an argument to other ditto_* functions. The Ditto
 * object must be stopped and freed with ditto_free().
 */
struct Ditto *ditto_make_production(struct UninitializedDitto *uninit_ditto_raw,
                                    const char *certificate_config_str);

/**
 * Creates new Attachment from a file and link it to the given Document.
 *
 * Returns following error codes:
 *
 * * `0` -- no error
 * * `1` -- an error
 * * `2` -- file not found
 * * `3` -- permission denied
 *
 * In case of a non-zero return value, error message can be retrieved using
 * `::ditto_error_message` function.
 */
unsigned int ditto_new_attachment_from_file(struct Ditto *ditto_raw,
                                            const char *source_path,
                                            enum AttachmentFileOperation file_operation,
                                            const unsigned char **out_id_ptr,
                                            uintptr_t *out_id_len,
                                            uint64_t *out_len,
                                            const struct AttachmentHandle **out_handle);

/**
 * Request data showing who we are connected to in a user-friendly way.
 */
char *ditto_presence_v1(struct Ditto *ditto_raw);

int ditto_queries_hash(struct Ditto *ditto_raw,
                       const char *const *c_coll_names,
                       const Ditto_CompiledQuery *const *c_queries,
                       unsigned int len,
                       unsigned long long *c_hash);

int ditto_queries_hash_mnemonic(struct Ditto *ditto_raw,
                                const char *const *c_coll_names,
                                const Ditto_CompiledQuery *const *c_queries,
                                unsigned int len,
                                const char **c_mnemonic_hash);

/**
 * Compiles string query into JMESPath query
 *
 * Return codes:
 *
 * * `QUERY_COMPILE_SUCCESS` -- success
 * * `QUERY_COMPILE_COMPILE_FAILED` -- invalid expression
 */
enum Ditto_QueryCompileResult ditto_query_compile(const char *expr, Ditto_CompiledQuery **query);

void ditto_query_filter_free(const struct Ditto_QueryFilter *query_filter);

int ditto_query_filter_next(const struct Ditto_QueryFilter *query_filter,
                            const struct Ditto_Document **document);

/**
 * Releases memory held by a compiled query
 */
void ditto_query_free(Ditto_CompiledQuery *query);

/**
 * Compiles JMESPath query
 *
 * Return codes:
 *
 * * `QUERY_COMPILE_SUCCESS` -- success
 * * `QUERY_COMPILE_COMPILE_FAILED` -- invalid expression
 */
enum Ditto_QueryCompileResult ditto_query_jmespath_compile(const char *expr,
                                                           Ditto_CompiledQuery **query);

int ditto_read_transaction(struct Ditto *ditto_raw, const struct Ditto_ReadTransaction **txn);

void ditto_read_transaction_free(const struct Ditto_ReadTransaction *transaction);

int ditto_read_transaction_query(struct Ditto *ditto_raw,
                                 const char *coll_name,
                                 const struct Ditto_ReadTransaction *transaction,
                                 const Ditto_CompiledQuery *query,
                                 const struct Ditto_OrderDefinition *order_by,
                                 unsigned int order_by_len,
                                 int limit,
                                 unsigned int offset,
                                 const struct Ditto_QueryFilter **query_filter);

int ditto_read_transaction_query_filter(struct Ditto *ditto_raw,
                                        const char *coll_name,
                                        const struct Ditto_ReadTransaction *transaction,
                                        const Ditto_CompiledQuery *query,
                                        const struct Ditto_QueryFilter **query_filter);

/**
 * Register a function that will be called every time the connection state
 * of remote peers changes.
 */
void ditto_register_presence_v1_callback(struct Ditto *ditto_raw,
                                         void *ctx,
                                         void (*retain)(void*),
                                         void (*release)(void*),
                                         void (*c_cb)(void*, const char*));

/**
 * Register a function that will be called every time a transport changes
 * condition.
 *
 * This should drive UI indicators to indicate overall connectivity via methods
 * such as BLE, WiFi, or an internet-based server on a dedicated
 * WsConnectTransport.
 */
void ditto_register_transport_condition_changed_callback(struct Ditto *ditto_raw,
                                                         void *ctx,
                                                         void (*retain)(void*),
                                                         void (*release)(void*),
                                                         void (*c_cb)(void*, enum ConditionSource, enum TransportCondition));

void ditto_remove_mdns_advertiser(struct Ditto *ditto_raw);

void ditto_remove_subscription(struct Ditto *ditto_raw, const char *collection, const char *query);

/**
 * Remove a transport.
 */
void ditto_remove_transport(struct Ditto *ditto_raw, long long id);

/**
 * Register a new callback to resolve the attachment.
 *
 * The callback status could be:
 * * `0` -- complete, with a handle that can be used in ditto_get_complete_attachment_path
 * * `1` -- incomplete, with additional progress info
 * * `2` -- deleted, as the attachment ceased to exist in the doc database
 *
 * Returns following error codes:
 *
 * * `0` -- no error
 * * `1` -- an error
 * * `2` -- invalid id
 * * `3` -- attachment not found
 *
 * In case of a non-zero return value, error message can be retrieved using
 * `::ditto_error_message` function.
 */
unsigned int ditto_resolve_attachment(struct Ditto *ditto_raw,
                                      const unsigned char *id_ptr,
                                      uintptr_t id_len,
                                      void *ctx,
                                      int64_t *out_cancel_token,
                                      void (*on_complete_cb)(void *ctx, struct AttachmentHandle*),
                                      void (*on_incomplete_cb)(void *ctx, uint64_t, uint64_t),
                                      void (*on_deleted_cb)(void *ctx));

int ditto_restart_tcp_server(struct Ditto *ditto_raw);

void ditto_set_device_name(struct Ditto *ditto_raw, const char *device_name);

/**
 * Start the WebSocket server
 */
int ditto_start_tcp_server(struct Ditto *ditto_raw, const char *bind);

void ditto_stop_all_live_queries(struct Ditto *ditto_raw);

int ditto_stop_tcp_server(struct Ditto *ditto_raw);

/**
 * Listen address of tcp_listen_transport. Must be called after
 * transport_go_online. The return value must be freed with
 * ditto_c_string_free().
 */
char *ditto_tcp_server_listen_addr(struct Ditto *ditto_raw);

/**
 * Transport go offline.
 */
void ditto_transport_go_offline(struct Ditto *ditto_raw, long long id);

/**
 * Request bulk status information about the transports. Intended mostly for
 * statistical or debugging purposes.
 */
char *ditto_transports_diagnostics(struct Ditto *ditto_raw);

void ditto_vec_documents_free(const struct Ditto_Document **docs, uintptr_t doc_count);

void ditto_vec_usizes_free(uintptr_t *usizes, uintptr_t usize_count);

int ditto_write_transaction(struct Ditto *ditto_raw, const struct Ditto_WriteTransaction **txn);

int ditto_write_transaction_commit(const struct Ditto_WriteTransaction *transaction);

void ditto_write_transaction_free(const struct Ditto_WriteTransaction *transaction);

int ditto_write_transaction_query(struct Ditto *ditto_raw,
                                  const char *coll_name,
                                  const struct Ditto_WriteTransaction *transaction,
                                  const Ditto_CompiledQuery *query,
                                  const struct Ditto_OrderDefinition *order_by,
                                  unsigned int order_by_len,
                                  int limit,
                                  unsigned int offset,
                                  const struct Ditto_QueryFilter **query_filter);

int ditto_write_transaction_query_filter(struct Ditto *ditto_raw,
                                         const char *coll_name,
                                         const struct Ditto_WriteTransaction *transaction,
                                         const Ditto_CompiledQuery *query,
                                         const struct Ditto_QueryFilter **query_filter);

void ditto_write_transaction_rollback(const struct Ditto_WriteTransaction *transaction);

/**
 * The platform advises Rust that the status of publishing our service has
 * changed.
 */
void mdns_advertising_state_changed(const MdnsServerPlatformHandle *handle,
                                    enum OnlineState state,
                                    enum TransportCondition condition);

/**
 * The SDK requests to drop its handle to the mDNS discovery transport
 *
 * At some point dropping this events channel will effectively shut down and remove the Transport.
 * At time of writing, the Transport is still owned within Peer.
 */
void mdns_client_free_handle(MdnsClientPlatformHandle *handle);

/**
 * Request the id of this transport
 *
 * This is a temporary accessor until the Peer transports interface is removed.
 */
long long mdns_client_transport_id(const MdnsClientPlatformHandle *handle);

/**
 * The platform advises Rust that a peer has been identified
 */
void mdns_platform_peer_appeared(const MdnsClientPlatformHandle *handle,
                                 const char *announce_string);

/**
 * The platform advises Rust that a peer's service has disappeared from mDNS.
 */
void mdns_platform_peer_disappeared(const MdnsClientPlatformHandle *handle,
                                    const char *announce_string);

/**
 * The platform advises Rust that the status of searching for services has changed.
 */
void mdns_scanning_state_changed(const MdnsClientPlatformHandle *handle,
                                 enum OnlineState state,
                                 enum TransportCondition condition);

/**
 * The SDK requests to drop its handle to the mDNS advertising service.
 *
 * Ideally this should remove the advertiser automatically.
 * At time of writing now this must be done manually through Peer.
 */
void mdns_server_free_handle(MdnsServerPlatformHandle *handle);

/**
 * The platform advises Rust that we failed to resolve a peer's hostname and port
 */
void mdns_service_did_not_resolve(const MdnsClientPlatformHandle *handle,
                                  const char *announce_string);

/**
 * The platform advises Rust that we have resolved a peer's hostname and port
 */
void mdns_service_did_resolve(const MdnsClientPlatformHandle *handle,
                              const char *announce_string,
                              const char *hostname,
                              unsigned int port);

/**
 * The SDK requests to drop its handle to this TCP Client transport
 */
void static_tcp_client_free_handle(StaticTcpClientPlatformHandle *handle);

/**
 * Check the store for an existing cached site ID. Returns 0 if there no
 * existing site ID could be fetched.
 */
unsigned int uninitialized_ditto_get_site_id(struct UninitializedDitto *uninit_ditto_raw);

/**
 * Make an UninitializedDitto object as an opaque pointer. This object serves
 * as an intermediate object that allows database access. This allows the SDK
 * to check if a pre-existing site ID has been persisted.
 */
struct UninitializedDitto *uninitialized_ditto_make(const char *working_dir, uintptr_t mapsize);

/**
 * verify a base64 encoded license string
 *
 * returns:
 * - 0 if signature is valid
 * - -1 if signature is invalid
 * - -2 if the license is expired
 * - -3 if the base64 license string was not decodable by base64 crate
 * - -4 if anything else failed
 */
int verify_license(const char *license_str);

#endif
/** \file dittoffi.h */
